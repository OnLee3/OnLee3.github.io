---
title: "[백준] 12015 가장 긴 증가하는 부분 수열 2"
layout: single
categories: 알고리즘
# excerpt: "개방형 시스템 상호 연결 모델의 표준"
thumbnail: https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png
excerpt: 기존에 한번 풀어봤던 최장길이 부분 수열 문제. 다만 이번엔 크기가 1,000,000으로 기존 dp풀이대로 하면 O(n**2)의 시간복잡도를 가지므로 통과할 수 없다.
toc: true
toc_sticky: true
---

>[12015번: 가장 긴 증가하는 부분 수열 2](https://www.acmicpc.net/problem/12015)
>

## 문제

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.

### 입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000,000)

### 출력

첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

### 예제 입력 1

```
6
10 20 10 30 20 50
```

### 예제 출력 1

```
4
```

## 문제풀이

기존에 한번 풀어봤던 최장길이 부분 수열 문제. 다만 이번엔 크기가 1,000,000으로 기존 dp풀이대로 하면 O(n**2)의 시간복잡도를 가지므로 통과할 수 없다.

> DP (시간초과)
> 

```python
n=int(input())
sequence=list(map(int, input().split()))
dp=[1]*n

for i in range(n):
  for j in range(i):
    if sequence[j] < sequence[i]:
      dp[i] = max(dp[i], dp[j]+1)
print(max(dp))
```

최장수열길이를 알아낼 스택을 하나 만든다. 가령 `[10, 20, 15, 20, 14, 50]` 수열이 주어진다면, **맨 앞에서부터 수열을 훑으며 이분탐색으로 스택에 들어갈 위치를 결정한다.** 즉 이분탐색은 `logN` 이고 배열의 탐색은 `N`만큼의 시간이 걸리므로, `NlogN`의 시간복잡도로 해결할 수 있다.

> 이분탐색 응용
> 

```python
from bisect import bisect_left

n=int(input())
sequence=list(map(int, input().split()))
stack=[sequence[0]]

for item in sequence:
  if stack[-1] < item:
    stack.append(item)
  else:
    left_index = bisect_left(stack, item)
    stack[left_index] = item
print(len(stack))
```

자세히 과정을 들여다 보자. `[10, 20, 15, 20, 14, 50]`

1. 스택을 수열 첫 원소인 `[10]` 로 초기화한다.
2. 다음 원소인 `20`은, `10`보다 크므로 최장길이수열이 될수 있다. 그대로 스택에 `append` 해준다.
3. 다음 원소인 `15`는, `20`보다 작으므로, 현재 스택 `[10, 20]` 에서 들어갈 인덱스를 구한다(`이분탐색`).
    - 스택 맨앞에서부터 확인해 `15`보다 큰 인덱스.
4. `20`을 `15`로 교체해준다. `[10, 15]`
5. ... 반복문(`2~4과정`)을 마쳤을때 스택의 길이를 리턴한다.

```python
[10]
[10, 20]
[10, 15]
[10, 15, 20]
[10, 14, 20]
[10, 14, 20, 50]
```

여기서 두가지 의문이 들 수 있다.

1. `[10, 14, 20, 50]` 이 가능한 최장길이 수열의 형태인가?
2. 탐색하는 원소가 스택 맨뒤의 숫자보다 작을때 왜 인덱스를 교체해줘야 하는가?

### `[10, 14, 20, 50]` 이 가능한 최장길이 수열의 형태인가?

`[10, 20, 15, 20, 14, 50]` 기존 배열의 형태를 생각하면 옳지 않은 최장길이수열의 형태이다. **그러나 길이만을 구한다고 하면 성립한다.** 이에 대한 설명은 두번째 의문과도 연결된다.

### 탐색하는 원소가 스택 맨뒤의 숫자보다 작을때 왜 인덱스를 교체해줘야 하는가?

위의 과정에서 `[10, 20]` ⇒ `[10, 15]`등 으로 인덱스가 교체되는걸 확인할 수 있다. 이로 인해 만약 `15 ~ 20` 사이의 숫자, `17`이 뒤에 있다고 가정하면 `[10, 15]` 뒤에 붙어서 `[10, 15, 17]` 의 형태를 만들 수 있다. 즉 교체해주지 않으면 놓치는 최장길이부분수열이 생긴다. **반대로 기존 숫자 `20`이여야만 뒤에 붙을 수 있는 숫자는 존재하지 않기 때문에**, 항상 교체해주는게 옳다.