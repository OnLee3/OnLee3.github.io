---
title: "[백준] 1107 리모컨"
layout: single
categories: [알고리즘]
tags: [백준, 파이썬]
thumbnail: https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png
excerpt: 탐색할 숫자를 문자열로 변환시켜 각 자릿수가 고장난 버튼에 속할경우, 무시하고 넘긴다. 모든 자릿수가 문제 없을 경우, 위에서 구한 공식 `누른 자릿수 + abs(목표버튼 - 조합버튼)`를 하고, 기존 이동량이랑 비교해서 최소값을 갱신한다.
toc: true
toc_sticky: true
---

>[1107번: 리모컨](https://www.acmicpc.net/problem/1107)
>

## 문제

수빈이는 TV를 보고 있다. 수빈이는 채널을 돌리려고 했지만, 버튼을 너무 세게 누르는 바람에, 일부 숫자 버튼이 고장났다.

리모컨에는 버튼이 0부터 9까지 숫자, +와 -가 있다. +를 누르면 현재 보고있는 채널에서 +1된 채널로 이동하고, -를 누르면 -1된 채널로 이동한다. 채널 0에서 -를 누른 경우에는 채널이 변하지 않고, 채널은 무한대 만큼 있다.

수빈이가 지금 이동하려고 하는 채널은 N이다. 어떤 버튼이 고장났는지 주어졌을 때, 채널 N으로 이동하기 위해서 버튼을 최소 몇 번 눌러야하는지 구하는 프로그램을 작성하시오.

수빈이가 지금 보고 있는 채널은 100번이다.

> 입력

첫째 줄에 수빈이가 이동하려고 하는 채널 N (0 ≤ N ≤ 500,000)이 주어진다.  둘째 줄에는 고장난 버튼의 개수 M (0 ≤ M ≤ 10)이 주어진다. 고장난 버튼이 있는 경우에는 셋째 줄에는 고장난 버튼이 주어지며, 같은 버튼이 여러 번 주어지는 경우는 없다.

> 출력

첫째 줄에 채널 N으로 이동하기 위해 버튼을 최소 몇 번 눌러야 하는지를 출력한다.

> 예제 입력 1

```
5457
3
6 7 8
```

> 예제 출력 1

```
6
```

> 예제 입력 2

```
100
5
0 1 2 3 4
```

> 예제 출력 2

```
0
```

> 예제 입력 3

```
500000
8
0 2 3 4 6 7 8 9
```

> 예제 출력 3

```
11117
```

> 예제 입력 4

```
100
3
1 0 5
```

> 예제 출력 4

```
0
```

> 예제 입력 5

```
14124
0
```

> 예제 출력 5

```
5
```

> 예제 입력 6

```
1
9
1 2 3 4 5 6 7 8 9
```

> 예제 출력 6

```
2
```

> 예제 입력 7

```
80000
2
8 9
```

> 예제 출력 7

```
2228
```

## 문제풀이
### 고민한 사항
최소한으로 버튼을 누르는 건 총 두가지 경우가 있다고 생각하고 접근했다.

1. 시작 채널에서 목표 채널로 +, -를 통해 바로 이동하기
    
    `abs(n-100)`
    
2. 고장나지 않은 버튼을 조합해서 목표에 가깝게 이동한뒤, 목표 채널과의 차이만큼 +,-를 통해 이동하기
    
    `누른 자릿수 + abs(목표버튼 - 조합버튼)` 가 되겠다.
    

여기서 2번과정을 구하는게 막막했다. 목표숫자의 각자리의 숫자들을 고장나지 않은 숫자중에서 가장 가까운걸 선택하는 알고리즘을 생각하는데, 마냥 가깝기만 하다고 해서 최적의 해가 아님을 깨달았다. 자릿수가 넘어가면서 바뀔수도 있으며, 앞뒤자리의 숫자에 따라 변동이 있다. 그래서 n의범위(`500,000`)가 그리 크지도 않으므로, 단순하게 완전탐색으로 해결하기로 했다.

### 정답

```python
import sys

def input():
  return sys.stdin.readline().rstrip()

n = int(input())
m = int(input())
ooo = input().split()

move = abs(n - 100)

for i in range (int(1e6)+1):
  nums = str(i)
  for j in range(len(nums)):
    if nums[j] in ooo:
      break
  else:
    move = min(move, abs(n-i)+len(nums))
      
print(move)
```

1부터 백만까지 모든 숫자를 탐색한다. 여기서 입력최대범위가 500,00인데 백만을 지정한건, 백만을 넘어 자릿수가 바뀌기 전까지 모든 숫자에서 출발하여 목표 숫자로 이동할 수 있기 때문이다. 즉 십만을 탐색하기 위해, 버튼을 눌러 십오만으로 목표 숫자보다 큰 곳에서 출발할 수 도 있다.

탐색할 숫자를 문자열로 변환시켜 각 자릿수가 고장난 버튼에 속할경우, 무시하고 넘긴다. 모든 자릿수가 문제 없을 경우, 위에서 구한 공식 `누른 자릿수 + abs(목표버튼 - 조합버튼)`를 하고, 기존 이동량이랑 비교해서 최소값을 갱신한다.