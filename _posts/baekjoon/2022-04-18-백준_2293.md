---
title: "[백준] 2293 동전 1"
layout: single
categories: [알고리즘]
tags: [백준, 파이썬]
thumbnail: '/assets/images/algorithm/baekjoon.png'
header:
  overlay_image: '/assets/images/algorithm/baekjoon.png'
  overlay_filter: 0.5
excerpt: n행은 '각 동전을 가지고 있을 때’, 를 의미한다. 즉 위의 예시라면 1원 동전일때 구할 수 있는 경우의 수, 그 후 1원 2원 동전일때의 경우의 수, 마지막으로 1원, 2원, 5원일때의 경우의 수를 구해주면 된다.
toc: true
toc_sticky: true
---

>[2293번: 동전 1](https://www.acmicpc.net/problem/2293)
>

## 문제

n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.

사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.

> 입력

첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.

> 출력

첫째 줄에 경우의 수를 출력한다. 경우의 수는 231보다 작다.

> 예제 입력 1

```
3 10
1
2
5
```

> 예제 출력 1

```
10
```

## 문제풀이

역시나 점화식을 구하는게 고역이다. 고민하다 결국 아이디어는 다른 사람의 설명을 듣고 구현했다. 

### 실패흔적

`n*k` 형태의 dp배열을 만드는걸 예상했다. 각 좌표에  `k` 가치일때의 경우의 수를 저장하는게 아닐까 생각했지만, `n`행이 무엇을 의미하는지 생각이 미치지 못했다.

### 정답

`n`행은 ‘**각 동전을 가지고 있을 때’**, 를 의미한다. 즉 위의 예시라면 1원 동전일때 구할 수 있는 경우의 수, 그 후 1원 2원 동전일때의 경우의 수, 마지막으로 1원, 2원, 5원일때의 경우의 수를 구해주면 된다.

`dp[0]`는 각 동전하나로 조건을 만족시키는 경우다. 1원 동전으로 시작한다면, k=1은 당연히 1이 되야하고, k=2라면 기존 1원동전으로 체크된 경우의 수 1 `(1,1)` 과 **2원 동전 1개 경우** 의 합으로 2가 되야한다.

즉 2차원 배열을 만들 필요없이, 일차원 배열에서 동전의종류만큼 순회하면 되는데, 이를 식으로 나타내면 `dp[j] = dp[j] + dp[j-coin]`이 된다. 

```python
n, k = map(int, input().split())
coins = [int(input()) for _ in range(n)]
dp=[1] + [0]*k

for coin in coins:
  for j in range(coin, k+1):
    dp[j] += dp[j-coin]
print(dp[k])
```