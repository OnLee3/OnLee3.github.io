---
title: "[백준] 14500 테트로미노"
layout: single
categories: [알고리즘]
tags: [백준, 파이썬]
thumbnail: '/assets/images/algorithm/baekjoon.png'
header:
  overlay_image: '/assets/images/algorithm/baekjoon.png'
  overlay_filter: 0.5
excerpt: 블록은 대칭, 회전이 가능하므로 총 19가지 모양이 가능하다. 각 모양에 따른 이동규칙을 배열로 만들어주고, 2차원배열에 전부 대입해본다. 최악의경우 19 * 500 * 500 으로 파이썬으로도 충분히 커버할만한 정도의 시간복잡도를 가지므로 가능하다 판단했다. 다만 모양에 따른 좌표를 일일히 만드는게 토나올 것 같았다.
toc: true
toc_sticky: true
---

>[14500번: 테트로미노](https://www.acmicpc.net/problem/14500)
>

## 문제

폴리오미노란 크기가 1×1인 정사각형을 여러 개 이어서 붙인 도형이며, 다음과 같은 조건을 만족해야 한다.

- 정사각형은 서로 겹치면 안 된다.
- 도형은 모두 연결되어 있어야 한다.
- 정사각형의 변끼리 연결되어 있어야 한다. 즉, 꼭짓점과 꼭짓점만 맞닿아 있으면 안 된다.

정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 다음과 같은 5가지가 있다.

![https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14500/1.png](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14500/1.png){: .align-center}

아름이는 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다.

테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 하는 프로그램을 작성하시오.

테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.

> 입력

첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500)

둘째 줄부터 N개의 줄에 종이에 쓰여 있는 수가 주어진다. i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다. 입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다.

> 출력

첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.

> 예제 입력 1

```
5 5
1 2 3 4 5
5 4 3 2 1
2 3 4 5 6
6 5 4 3 2
1 2 1 2 1
```

> 예제 출력 1

```
19
```

> 예제 입력 2

```
4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
```

> 예제 출력 2

```
20
```

> 예제 입력 3

```
4 10
1 2 1 2 1 2 1 2 1 2
2 1 2 1 2 1 2 1 2 1
1 2 1 2 1 2 1 2 1 2
2 1 2 1 2 1 2 1 2 1
```

> 예제 출력 3

```
7
```

## 문제풀이

구현이 까다로운 완전탐색 문제. `4 ≤ N, M ≤ 500`의 2차원 위에서, 테트리스 블록 하나만을 사용하여 가장 큰 점수를 얻는 경우를 반환하는 문제이다. 

### 고민

블록은 대칭, 회전이 가능하므로 총 19가지 모양이 가능하다. 각 모양에 따른 이동규칙을 배열로 만들어주고, 2차원배열에 전부 대입해본다. 최악의경우 `19 * 500 * 500` 으로 파이썬으로도 충분히 커버할만한 정도의 시간복잡도를 가지므로 가능하다 판단했다. 다만 모양에 따른 좌표를 일일히 만드는게 토나올 것 같았다.

### 정답

```python
import sys

def input():
  return sys.stdin.readline().rstrip()

tetro = [[(0, 1), (0, 2), (0, 3)], # 긴 가로
         [(1, 0), (2, 0), (3, 0)], # 긴 세로
         [(0, 1), (1, 0), (1, 1)], # 네모
         [(0, 1), (1, 1), (0, 2)], # T
         [(0, 1), (-1, 1), (1, 1)], # ㅓ
         [(0, 1), (-1, 1), (0, 2)], # ㅗ
         [(1, 0), (1, 1), (2, 0)], # ㅏ
         [(1, 0), (1, 1), (2, 1)], # Z
         [(0, 1), (-1, 1), (-1, 2)], # Z 오른쪽
         [(-1, 0), (-1, 1), (-2, 1)], # Z 대칭
         [(0, 1), (1, 1), (1, 2)], # Z 대칭 오른쪽
         [(1, 0), (2, 0), (2, 1)], # ㄴ
         [(1, 0), (0, 1), (0, 2)], # ㄴ 오른쪽 
         [(0, 1), (1, 1), (2, 1)], # ㄴ 아래쪽
         [(0, 1), (0, 2), (-1, 2)], # ㄴ 왼쪽
         [(0, 1), (-1, 1), (-2, 1)], # ㄴ 대칭
         [(1, 0), (1, 1), (1, 2)], # ㄴ 대칭 오른쪽 
         [(-1, 0), (-2, 0), (-2, 1)], # ㄴ 대칭 아래쪽
         [(0, 1), (0, 2), (1, 2)] # ㄴ 대칭 왼쪽
        ]

n, m = map(int, input().split())
board = [list(map(int, input().split())) for _ in range(n)]
answer=0

for piece in tetro:
  for i in range(n):
    for j in range(m):
      tmp=board[i][j]
      for k in range(3):
        nx = i + piece[k][0]
        ny = j + piece[k][1]
        if 0 <= nx < n and 0 <= ny < m:
          tmp += board[nx][ny]
        else:
          break
      else:
        answer = max(answer, tmp)

print(answer)
```