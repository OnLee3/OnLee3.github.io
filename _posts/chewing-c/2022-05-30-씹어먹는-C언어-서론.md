---
title: "[모두의코드] C언어 서론"
layout: single
categories: [개발지식]
tags: [모두의코드, C]
thumbnail: /assets/images/ChewingClogo.webp
header:
    overlay_image: /assets/images/ChewingClogo.webp
    overlay_filter: 0.5
excerpt: "컴퓨터는 모든 과정을 이진법으로 이해한다."
toc: true
toc_sticky: true
---

> [모두의 코드: 내가 C 언어를 공부하기 전에 알았으면 좋았을 것들](https://modoocode.com/315) 강의를 듣고 정리한 내용입니다.
>

## 서론

### 특징

- 48년전 C언어와 지금 C언어는 같다. 현재 와서 배우기 어려운 이유는 다음과 같다.
    1. 컴퓨터 성능의 차이가 크다. (예전 컴퓨터의 메모리는 64KB)
    2. 프로그래밍이 대중적이지 않았기에, 초심자를 고려해 설계하지 않았다.
- 책으로 나타내면 200쪽 분량으로 기능을 전부 파악할 수 있을만큼, 언어로써 분량은 적은 편이다.
- C언어에서 파생된 언어가 많다.

### 결론

- 한번 배워두면 오래오래 써먹을 수 있다.
- 추상화 정도가 적기 때문에, 직접적으로 하드웨어와 시스템을 건드리는 공부를 할 수 있다. (수동운전과 자동운전의 차이로 비유)

## CPU 메모리

### 컴퓨터란

- 스스로 명령어를 읽어들여서 연산을 수행할 수 있다. (계산기와 컴퓨터의 차이)

### 누가 명령어를 읽는가?

- **CPU (Central Processing Unit) 중앙처리장치**
- 많은 열을 내뿜고 민감한 장치이기때문에, 알루미늄판과 쿨러를 통해 냉각 및 보호를 한다.
- 1초에 10억번 이상의 연산.

### 어디에서 명령어를 읽는가?

- CPU가 연산을 수행하기 위해서 저장하는 공간 (레지스터)는 크기가 작다. (64비트 CPU의 경우 레지스터 8바이트짜리 총 16개로, 128바이트의 크기다.)
- 따라서 저장에 특화된 장치가 따로 필요하다.
    
    ⇒ **메모리 (RAM)(Random Access Memory)**
    

**RAM**

![ram2.png](https://modoocode.com/img/c/ram2.png){: .align-center}

- 1바이트 크기 연속된 방으로 이루어짐.
- 어느 주소에 접근하더라도 동일한 속도를 낸다. (1번 주소, 100만번 주소)
- 메모리의 각 공간에 고유의 주소값을 표기한다.  1바이트의 공간으로 보통 16진수로 표기한다.
    - 예) 0x1200
- 다른 저장장치들에 비해 속도가 매우 빠르다. (데이터를 읽고 쓰는데 100나노초 정도)
- 휘발성 (컴퓨터를 끄면 데이터가 날라감. HDD, SDD와의 차이)

**CPU와 RAM의 속도**

- RAM이 다른 저장장치들에 비해 빠르다고는 했지만, CPU와 비교하면 턱없이 느리다.
- CPU에서 연산 1개: 0.3 나노초
- 램에서 읽기: 100 나노초
- 대략 300배의 차이가 난다. 따라서 CPU에 데이터를 잠시 보관할 방법을 찾게 된다.
    - 캐시 (Cache)
    - L1 Cache, L2 Cache, L3 Cache 등의 명칭으로 CPU에 붙어있다.
    - 숫자가 클수록 공간은 넓지만 속도는 느리다.

### 어떻게 명령어를 작성하는가?

- 각 CPU마다 인식하고 실행할 수 있는 명령어가 다르다.
- 명령어 집합 (ISA)
    - intel : x86
    - ARM: ARM
    - RISC-V: RISC-V
- 각 CPU에 맞는 명령어 표를 보고, 명령어를 작성해서 보내면 명령어를 이진법으로 받아들인다.
- 그러나 이는 사람이 이해하기 어렵기때문에, **그나마 사람이 잘 이해할 수 있는 형태로 변환한 것이 어셈블리이다.**

**CPU에서 RAM에 데이터 쓰기**

```
mov eax, 4660
# 4660(0x1234를 십진수로 표현)을 eax에 복사하라는 의미.
# eax: 레지스터 이름
mov BYTE PRT [rax], 3
# BTYE PRT : 전달한 주소값으로부터 1바이트 만큼을 덮어 씌운다.
# rax: eax 레지스터의 마지막 32 비트
```

**CPU가 명령어를 읽어들이는 방법**

1. CPU는 어디에서 실행할 명령어를 가져올까?
    - 램
2. 램 어디에서 가져올지 어떻게 알까?
    - 명령어 주소 레지스터 `(RIP) (Register Instruction Pointer)`

```
0x401340 push rbp
0x401341 mov rbp, rsp
0x401344 mov DWORD PTR [rbp - 4], edi
0x401347 mov DWORD PTR [rbp - 8], esi
```

- CPU가 순서대로 RIP 레지스터 값을 업데이트 하면서 명령어들을 읽어나간다.

**프로그램을 실행한다는 의미**

- 하드 디스크 (혹은 SSD)에서 프로그램 정보를 램에 복사한다.
- 프로그램의 시작 위치로 RIP를 설정한다.

### 가상메모리와 물리메모리

- 메모리주소가 0x1234 로 표기 되있더라도 실제 메모리 주소는 이와 다를 수 있다.
- 그림판, 크롬 등 여러 응용프로그램을 사용할때 메모리주소가 겹칠수도 있기 때문에, 실제로는 특별한 1대1 변환과정을 통해 다른 곳에 있는 메모리 주소를 참조한다.
- 즉 CPU가 참조하는 메모리 주소값은 가상 메모리고, 실제 메모리의 주소값은 물리 메모리라고 한다. 이 변환 과정을 페이징이라고 부른다.

### 결론

- 위와같은 어셈블리를 이용하여 CPU에 명령을 내릴 수 있지만, 복잡하다.
- 따라서 사람이 이해하기 쉽게 명령어를 작성한뒤, 어셈블리로 변환시킬 프로그램을 찾게 된다. **이것이 프로그래밍 언어고, 어셈블리로 바꿔주는 과정을 컴파일 이라고 한다.**