---
title: "백준 12865 평범한 배낭"
layout: single
categories: [알고리즘, 백준, 파이썬]
# excerpt: "개방형 시스템 상호 연결 모델의 표준"
thumbnail: https://d2gd6pc034wcta.cloudfront.net/images/logo@2x.png
excerpt: 최댓값을 구하는 문제이기에, 동적계획법을 사용해야겠다고 생각이 들었다. 그래서 캐싱을 위한 `n * k` 형태의 2차원 배열을 만들어준다. n축은 각 물건을 나타내고, k축은 각 무게를 나타낸다.
toc: true
toc_sticky: true
---

>[12865번: 평범한 배낭](https://www.acmicpc.net/problem/12865)
>

## 문제

이 문제는 아주 평범한 배낭에 관한 문제이다.

한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.

준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

### 입력

첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.

입력으로 주어지는 모든 수는 정수이다.

### 출력

한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.

### 예제 입력 1

```
4 7
6 13
4 8
3 6
5 12
```

### 예제 출력 1

```
14
```

## 문제풀이

### **dp를 이용한 풀이**

상당히 고전했던 문제. 처음엔 2중 for문을 통해 각 물건에서 K를 초과하지 않을 만큼 다른 물건들을 담았었는데, 순차적으로 탐색하기 때문에 물건을 담으면, 다음 물건은 담지 못하는 경우가 있기 때문에, 모든 경우를 탐색할 수 없었다.

최댓값을 구하는 문제이기에, 동적계획법을 사용해야겠다고 생각이 들었다. 그래서 캐싱을 위한 `n * k` 형태의 2차원 배열을 만들어준다. n축은 각 물건을 나타내고, k축은 각 무게를 나타낸다. **즉 2중 for문으로 탐색한다고 했을때 dp[i][j]에는 j의 무게일때 i물건까지 탐색했을때의 최댓값이 담기게 된다.**

```
4 7
6 13
4 8
3 6
5 12
```

| N \ K | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 13 | 13 |
| 2 | 0 | 0 | 0 | 0 | 8 | 8 | 13 | 13 |
| 3 | 0 | 0 | 0 | 6 | 8 | 8 | 13 | 14 |
| 4 | 0 | 0 | 0 | 6 | 8 | 12 | 13 | 14 |

**상세과정**
1. 현재 탐색중인 물건의 무게 w가 j보다 크다면 `dp[i-1][j]`의 값을 그대로 가져온다. (무게 때문에 물건을 담을수 없으므로)
2. w가 j보다 작거나 같다면 탐색중인 물건을 담을 수 있다는 의미인데, 다음경우를 비교해보고 더 큰 가치를 배열에 담는다.
    1. 현재 물건의가치(`v`) + 남는 무게 만큼 이전배열에서의 최댓값(`dp[i-1][j-w]`)
    2. 이전 배열에서의 최댓값(`dp[i-1][j]`)

```python
n, k = map(int ,input().split())
dp=[[0]*(k+1) for _ in range(n+1)]

for i in range(1, n+1):
  w, v = map(int, input().split())
  for j in range(1, k+1):
    if w > j:
      dp[i][j] = dp[i-1][j]
    else:
      dp[i][j] = max(v+dp[i-1][j-w], dp[i-1][j])
print(dp[n][k])
```

### 사전 자료형을 이용한 풀이

더 적은 시간복잡도로 해결할 수 있는 풀이. 무게 별로 나올 수 있는 최댓값을 사전자료형에 저장해두고, 현재 탐색중인 물건 + 이전에 담아두었던 물건의 값이 더 크다면 교체해준다.

이때 사전자료형을 탐색하면서 사전자료형을 업데이트하면 오류가 발생하므로, 임시사전을 만든뒤 반복문이 1회 끝날때마다 업데이트 해준다.

```python
n, k = map(int ,input().split())
dp={0:0}

for _ in range(n):
  curr_w, curr_v = map(int, input().split())
  tmp={}
  for w, v in dp.items():
    if curr_w + w <= k and curr_v+v > dp.get(curr_w+w, 0):
      tmp[curr_w+w]=curr_v+v
  dp.update(tmp)
print(max(dp.values()))
```